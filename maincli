-- defining variables
local userInput = nil
local currentDirectory = [[A:\]]
local currentDriver = 1
local drive = disk.init(currentDriver)
local amountOfDrivesWhichTheUserHasStoredInTheConfigFile = drive.readFile("config.sys") or 1
local isRoot = false
local rootPassword = "logicallyf3x"
local isDebugging = false
local HttpService = GetService("HttpService")
local PacmanRefUrl = "https://raw.githubusercontent.com/lordnhoj1/Inio-Home-DOS/refs/heads/main/pacmandata"
local localVersion = "v1.2.2"

-- low-level shi(r)t and file management
local memory = {}
local memoryStep = 1
local fileTemp = drive.readFile("filememory.sys") or "filememory.sys" -- if a file is not referenced here, it is considered nonexistant, but can still be read by the user.
local fileMemory = fileTemp:split(" ")
local returnDriveFileStatus = drive.readFile("filememory.sys") or false -- to fix the issue above you would need to read every possible file name in the universe
if returnDriveFileStatus == false then
    drive.writeFile("filememory.sys", table.concat(fileMemory, " "))
end
local rsmFunc = {}
local function rsmfunc()
    return #rsmFunc + 1 or 1
end

-- functions so i can comply with all the linus rules

local function mount()
    local FileTemp = drive.readFile("filememory.sys") or "filememory"
    local FileMemory = FileTemp:split(" ")
    local fileDriveStatus = drive.readFile("filememory.sys") or false
    if fileDriveStatus == false then
        drive.writeFile("filememory.sys", "filememory.sys")
    end
    return FileMemory
end
local function update()
    drive.writeFile("filememory.sys", table.concat(fileMemory, " "))
end
local function safelyExit(err)
    clear()
    wait(1)
    print("Oops!\n\nInio has detected a major issue and decided to reboot for safety.\n\nPlease safely power off your device and restart after about 5 seconds.\n\nerr: " .. err)
end

-- table of directories (drivers)
local drivers = {
    [[A:\]],
    [[B:\]],
    [[C:\]],
    [[D:\]],
    [[E:\]],
    [[F:\]]
}
local driverBackup = {
    [[A:\]],
    [[B:\]],
    [[C:\]],
    [[D:\]],
    [[E:\]],
    [[F:\]]
}

-- extra modes
local function config()
    clear()
    print("Inio Hardware Manager\nv1 full release\n")
    print("Please enter how many drives you have.")
    amountOfDrivesWhichTheUserHasStoredInTheConfigFile = input()
    clear()
    print("Configged.")
    drive.writeFile("config.sys", amountOfDrivesWhichTheUserHasStoredInTheConfigFile)
    for i in pairs(fileMemory) do
        memory[memoryStep] = i + 1
    end
    fileMemory[memory[memoryStep]] = "config.sys"
    memory[memoryStep] = nil
    update()
end

local function texteditor(filename)
    clear()
    while wait(0.1) do
        userInput = input()
        print(userInput)
        memory[memoryStep] = userInput
        memoryStep = memoryStep + 1
        if userInput == "*exit" then
            local result = table.find(memory, "*exit")
            table.remove(memory, result)
            local storedFile = table.concat(memory, "\n")
            drive.writeFile(filename, storedFile)
            clear()
            print("exited")
            return
        end
    end
end

-- coding stuff
function CONSTRUCT_Token() -- this just creates a new token object because lua has no oop
  return { -- you can also put args into the consturct function instead of doing defaults
    ctype = "token",
    ttype = "", -- i like to use enums but lua has no custom enum feature ðŸ˜¡
    value = "",  -- hi lw ty for the code for these two functions mostly 
  }
end

local function lex(str)
  local tokens = {}
  for i = 1,str:len(),1 do -- you can NOT do :split(""), the i in here is important as some tokens are multiple characters
    local char = str:sub(i,i)
    if string.find("0123456789.",char) then
    local val = char
        while string.find("0123456789.",str:sub(i+1,i+1)) do
            wait()
            i=i+1;
            local c2 = str:sub(i,i)
            val = val..c2
        end
        local tok = CONSTRUCT_Token()
        tok.ttype = "num"
        tok.value = val
        table.insert(tokens,tok)
    end
    if string.find("+-*/^", char) then
        local val = char
        local tok = CONSTRUCT_Token()
        tok.ttype = "op"
        tok.value = val
        table.insert(tokens,tok)
    end
  end
  return tokens
end


-- defining file types and how they are ran
local fileTypes = {
    ["txt"] = function(filename)
        print(drive.readFile(filename))
    end,
    ["exe"] = function(filename)
        local requestedString = drive.readFile(filename)
        loadstring(requestedString, "InioFileManager")()
    end,
    ["rsm"] = function(filename)
        print("\n Inio Rossembly is the new standard for low-level programming. This feature is currently not finished.\n\nSent file: " .. filename .. "\n")
    end,
    ["hdql"] = function(filename)
        print("\nHigh-Level Database Querying Language is the greatest in its line for database management. This feature is currently not finished.\n\nSent file: " .. filename)
    end,
    ["min"] = function(filename)
        print("\nMinio is a next-generation language for automating the creation, deletion, and editing of text files. This feature is currently not finished.")
    end,
    ["sys"] = function(filename)
        print(drive.readFile(filename))
    end
}


-- command table
local cmds = {
    ["help"] = function()
        print("\nWelcome to Inio!\n\nCurrent commands: help, filehelp, specs, config, dir, clear, mkfile (filename), editfile (filename), readfile (filename), loadfile (filename), rmfile (filename), cd (drivernumber), su (rootpassword), filesize (filename), rfdinstall (requestedprogram), urlinstall (url, filename), debug, rfdlist")
    end,
    ["filehelp"] = function()
        print("\nWelcome to Inio!\nAll files must have one of the following extensions.\n    .txt, text file.\n    .exe, lua executable. \n    .rsm, Inio Rossembly executable.\n    .hdql, High Level Database Querying Language, SQL clone.\n    .sys, core system file.\n    .min, Minio file. Basically a macro.")
    end,
    ["specs"] = function()
        print("\nInio Home Edition "..localVersion"\nsu logicallyf3x rmfile filememory.sys\n\n" .. amountOfDrivesWhichTheUserHasStoredInTheConfigFile .. " connected drive(s).")
    end,
    ["config"] = function()
        config()
    end,
    ["dir"] = function()
        print("")
        local fileMem = drive.readFile("filememory.sys")
        fileMemory = fileMem:split(" ")
        for i in pairs(fileMemory) do
            print(fileMemory[i])
        end
    end,
    ["clear"] = function()
        clear()
    end,
    ["mkfile"] = function(filename)
        drive.writeFile(filename)
        memory[memoryStep] = #fileMemory + 1
        fileMemory[memory[memoryStep]] = filename
        memory[memoryStep] = nil
        memoryStep = 1
        update()
    end,
    ["readfile"] = function(filename)
        print("")
        print(drive.readFile(filename))
        print(" \n")
    end,
    ["editfile"] = function(filename)
        local fileData = filename:split(".")
        if fileData[2] == "sys" and isRoot == false then
            print("Cannot edit a system file.")
            return
        end
        texteditor(filename)
    end,
    ["loadfile"] = function(fileName)
        local fileData = fileName:split(".")
        fileTypes[fileData[2]](fileName)
    end,
    ["rmfile"] = function(filename)
        local fileData = filename:split(".")
        if fileData[2] == "sys" and isRoot == false then
            print("Cannot remove a system file.")
            return
        end
        drive.deleteFile(filename)
        local file = drive.readFile("filememory.sys")
        fileMemory = file:split(" ")
        for i,v in pairs(fileMemory) do
            if fileMemory[i] == filename then
                table.remove(fileMemory, i)
            end
        end
        update()
    end,
    ["cd"] = function(drivernumber)
        currentDriver = tonumber(drivernumber)
        drive = disk.init(currentDriver)
        currentDirectory = drivers[currentDriver]
        fileMemory = mount()
    end,
    ["su"] = function(rootPass)
        if rootPass == rootPassword and isRoot == false then
            isRoot = not isRoot
        else
            isRoot = false
        end
        if isRoot == true then
            for i,v in pairs(drivers) do
                drivers[i] = v..[[root\]]
            end
            currentDirectory = drivers[currentDriver]
        else
            for i in pairs(drivers) do
                drivers[i] = driverBackup[i]
            end
            currentDirectory = drivers[currentDriver]
        end
    end,
    ["filesize"] = function(filename)
        local file = drive.readFile(filename)
        local size = #file
        print(size .. " bytes")
    end,
    ["rfdinstall"] = function(requestedFilename)
        local PacmanRef = HttpService:GetAsync(PacmanRefUrl)
        local Packages = PacmanRef:split("+")
        for i,v in pairs(Packages) do
            local PackageData = v:split(" ")
            if PackageData[1] == requestedFilename then
                local Url = PackageData[2]
                local PackageContents = HttpService:GetAsync(Url)
                drive.writeFile(PackageData[1], PackageContents)
                memory[memoryStep] = #fileMemory + 1
                fileMemory[memory[memoryStep]] = PackageData[1]
                memory[memoryStep] = nil
                memoryStep = 1
                update()
            end
        end
    end,
    ["urlinstall"] = function(requestedUrl, filename)
        local contents = HttpService:GetAsync(requestedUrl)
        drive.writeFile(filename, contents)
        memory[memoryStep] = #fileMemory + 1
        fileMemory[memory[memoryStep]] = filename
        memory[memoryStep] = nil
        memoryStep = 1
        update()
    end,
    ["debug"] = function()
        isDebugging = not isDebugging
    end,
    ["rfdlist"] = function()
        local PacmanRef = HttpService:GetAsync(PacmanRefUrl)
        local PackagesTab = PacmanRef:split("+")
        for i,v in pairs(PackagesTab) do
            local Package = v:split(" ")
            print(Package[1])
        end
    end
}

-- little startup briefing
clear()
print("Inio Home Operating System\n" .. localVersion .. "\n")

-- main
local function cli()
    while wait() do
        write(currentDirectory)
        local userInputTemp = input()
        userInput = userInputTemp:split(" ")
        print(table.concat(userInput, " "))
	    local success, err = pcall(cmds[userInput[1]], userInput[2], userInput[3]) -- sudo rm -rf /
        if success then
            -- apparently i cant just do if error then so this is my solution
            -- this is very impractical and i would love to not use an if statement but it works so im not changing it
            -- update i removed error and this code does not infact work
            -- update i think it works even though its highly impractical and makes me cringe when i look at it
        else
            print("Command not found.")
            if isDebugging == true then
                print("\n\n" .. err)
            end
        end
    end
end



cli()
