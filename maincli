-- defining variables
local userInput = nil
local currentDirectory = [[A:\]]
local currentDriver = 1
local drive = disk.init(currentDriver)
local amountOfDrivesWhichTheUserHasStoredInTheConfigFile = drive.readFile("config.sys") or 1
local isRoot = false
local rootPassword = "logicallyf3x"

-- low-level shi(r)t and file management
local memory = {}
local memoryStep = 1
local fileTemp = drive.readFile("filememory.sys") or "filememory.sys" -- if a file is not referenced here, it is considered nonexistant, but can still be read by the user.
local fileMemory = fileTemp:split(" ")
local returnDriveFileStatus = drive.readFile("filememory.sys") or false -- to fix the issue above you would need to read every possible file name in the universe
if returnDriveFileStatus == false then
    drive.writeFile("filememory.sys", table.concat(fileMemory, " "))
end
local function mount()
    local FileTemp = drive.readFile("filememory.sys") or "filememory"
    local FileMemory = FileTemp:split(" ")
    local fileDriveStatus = drive.readFile("filememory.sys") or false
    if fileDriveStatus == false then
        drive.writeFile("filememory.sys", "filememory.sys")
    end
    return FileMemory
end
local function update()
    drive.writeFile("filememory.sys", table.concat(fileMemory, " "))
end
local function safelyExit(err)
    clear()
    wait(1)
    print("Oops!\n\nInio has detected a major issue and decided to reboot for safety.\n\nPlease safely power off your device and restart after about 5 seconds.\n\nerr: " .. err)
end

-- table of directories (drivers)
local drivers = {
    [[A:\]],
    [[B:\]],
    [[C:\]],
    [[D:\]],
    [[E:\]],
    [[F:\]]
}
local driverBackup = {
    [[A:\]],
    [[B:\]],
    [[C:\]],
    [[D:\]],
    [[E:\]],
    [[F:\]]
}

-- extra modes
local function config()
    clear()
    print("Inio Hardware Manager\nv1 full release\n")
    print("Please enter how many drives you have.")
    amountOfDrivesWhichTheUserHasStoredInTheConfigFile = input()
    clear()
    print("Configged.")
    drive.writeFile("config.sys", amountOfDrivesWhichTheUserHasStoredInTheConfigFile)
    for i in pairs(fileMemory) do
        memory[memoryStep] = i + 1
    end
    fileMemory[memory[memoryStep]] = "config.sys"
    memory[memoryStep] = nil
    update()
end

local function texteditor(filename)
    clear()
    while wait(0.1) do
        userInput = input()
        print(userInput)
        memory[memoryStep] = userInput
        memoryStep = memoryStep + 1
        if userInput == "*exit" then
            local result = table.find(memory, "*exit")
            table.remove(memory, result)
            local storedFile = table.concat(memory, "\n")
            drive.writeFile(filename, storedFile)
            clear()
            print("exited")
            print(currentDirectory)
            return
        end
    end
end

-- defining file types and how they are ran
local fileTypes = {
    ["txt"] = function(filename)
        print(drive.readFile(filename))
    end,
    ["exe"] = function(filename)
        loadstring(drive.readFile(filename))()
    end,
    ["rsm"] = function(filename)
        print("\n Inio Rossembly is the new standard for low-level programming. This feature is currently not finished.\n\nSent file: " .. filename)
    end,
    ["hdql"] = function(filename)
        print("\nHigh-Level Database Querying Language is the greatest in its line for database management. This feature is currently not finished.\n\nSent file: " .. filename)
    end,
    ["min"] = function(filename)
        print("\nMinio is a next-generation language for automating the creation, deletion, and editing of text files. This feature is currently not finished.")
    end,
    ["sys"] = function(filename)
        print(drive.readFile(filename))
    end
}


-- command table
local cmds = {
    ["help"] = function()
        print("\nWelcome to Inio!\n\nCurrent commands: help, filehelp, specs, config, dir, clear, newfile (filename), editfile (filename), readfile (filename), loadfile (filename), rmfile (filename), cd (drivernumber), su (rootpassword), filesize (filename)")
    end,
    ["filehelp"] = function()
        print("\nWelcome to Inio!\nAll files must have one of the following extensions.\n    .txt, text file.\n    .exe, lua executable. \n    .rsm, Inio Rossembly executable.\n    .hdql, High Level Database Querying Language, SQL clone.\n    .sys, core system file.\n    .min, Minio file. Basically a macro.")
    end,
    ["specs"] = function()
        print("\nInio Home Edition v1.1b\nBeetles Orbs\n\n" .. amountOfDrivesWhichTheUserHasStoredInTheConfigFile .. " connected drive(s).")
    end,
    ["config"] = function()
        config()
    end,
    ["dir"] = function()
        print("")
        local fileMem = drive.readFile("filememory.sys")
        fileMemory = fileMem:split(" ")
        for i in pairs(fileMemory) do
            print(fileMemory[i])
        end
    end,
    ["clear"] = function()
        clear()
    end,
    ["newfile"] = function(filename)
        drive.writeFile(filename)
        for i in pairs(fileMemory) do
            memory[memoryStep] = i + 1
        end
        fileMemory[memory[memoryStep]] = filename
        memory[memoryStep] = nil
        memoryStep = 1
        update()
    end,
    ["readfile"] = function(filename)
        print("")
        print(drive.readFile(filename))
        print(" \n" .. currentDirectory)
    end,
    ["editfile"] = function(filename)
        if filename == "filememory.sys" and isRoot == false then
            print("Cannot edit a system file.")
            return
        end
        texteditor(filename)
    end,
    ["loadfile"] = function(fileName)
        local fileData = fileName:split(".")
        fileTypes[fileData[2]](fileName)
    end,
    ["rmfile"] = function(filename)
        if filename == "filememory.sys" and isRoot == false then
            print("Cannot remove a system file.")
            return
        end
        drive.deleteFile(filename)
        local file = drive.readFile("filememory.sys")
        fileMemory = file:split(" ")
        for i,v in pairs(fileMemory) do
            if fileMemory[i] == filename then
                fileMemory[i] = nil
            end
        end
        update()
    end,
    ["cd"] = function(drivernumber)
        currentDriver = tonumber(drivernumber)
        drive = disk.init(currentDriver)
        currentDirectory = drivers[currentDriver]
        fileMemory = mount()
    end,
    ["su"] = function(rootPass)
        if rootPass == rootPassword then
            isRoot = not isRoot
        end
        if isRoot == true then
            for i,v in pairs(drivers) do
                drivers[i] = v..[[root\]]
            end
            currentDirectory = drivers[currentDriver]
        else
            for i in pairs(drivers) do
                drivers[i] = driverBackup[i]
            end
            currentDirectory = drivers[currentDriver]
        end
    end,
    ["filesize"] = function(filename)
        local file = drive.readFile(filename)
        local size = #file
        print(size .. " bytes")
    end
}

-- little startup briefing
clear()
print("Input 1 is automatically assigned to drive A. Please insert a disk drive and connect it to input 1 if you've haven't already.")
wait(6)
clear()
wait(1)
print("Inio Home Operating System\n v1.1 beta\n")

-- main
local function cli()
    print(currentDirectory)
    while wait(0.1) do
        local InputTransferrable = input()
        userInput = InputTransferrable:split(" ")
        print(currentDirectory .. table.concat(userInput, " "))
	    local success = pcall(cmds[userInput[1]], userInput[2] or nil) -- sudo rm -rf /
        if success then
            -- apparently i cant just do if error then so this is my solution
            -- this is very impractical and i would love to not use an if statement but it works so im not changing it
            -- update i removed error and this code does not infact work
            -- update i think it works even though its highly impractical and makes me cringe when i look at it
        else
            print("Command not found.")
        end
    end
end



cli()
