-- defining variables
local userInput = nil
local currentDirectory = [[A:\]]
local currentDriver = 1
local drive = disk.init(currentDriver)
local amountOfDrivesWhichTheUserHasStoredInTheConfigFile = drive.readFile("config") or 1

-- low-level shi(r)t and file management
local memory = {}
local memoryStep = 1
local fileTemp = drive.readFile("filememory") or "filememory" -- if a file is not referenced here, it is considered nonexistant, but can still be read by the user.
local fileMemory = fileTemp:split(" ")
local returnDriveFileStatus = drive.readFile("filememory") or false -- to fix the issue above you would need to read every possible file name in the universe
if returnDriveFileStatus == false then
    drive.writeFile("filememory", table.concat(fileMemory, " "))
end
local function mount()
    local FileTemp = drive.readFile("filememory") or "filememory"
    local FileMemory = FileTemp:split(" ")
    local fileDriveStatus = drive.readFile("filememory") or false
    if fileDriveStatus == false then
        drive.writeFile("filememory", "filememory")
    end
    return FileMemory
end

-- table of directories (drivers)
local drivers = {
    [[A:\]],
    [[B:\]],
    [[C:\]],
    [[D:\]],
    [[E:\]],
    [[F:\]]
}

-- extra modes
local function config()
    clear()
    print("Inio Hardware Manager\nv0.1 beta\n")
    print("Please enter how many drives you have.")
    amountOfDrivesWhichTheUserHasStoredInTheConfigFile = input()
    clear()
    print("Configged.")
    drive.writeFile("config", amountOfDrivesWhichTheUserHasStoredInTheConfigFile)
    for i in pairs(fileMemory) do
        memory[memoryStep] = i + 1
    end
    fileMemory[memory[memoryStep]] = "config"
    memory[memoryStep] = nil
end

local function texteditor(filename)
    clear()
    while wait(0.1) do
        userInput = input()
        print(userInput)
        memory[memoryStep] = userInput
        memoryStep = memoryStep + 1
        if userInput == "*exit" then
            local result = table.find(memory, "*exit")
            table.remove(memory, result)
            local storedFile = table.concat(memory, "\n")
            drive.writeFile(filename, storedFile)
            clear()
            print("exited")
            print(currentDirectory)
            return
        end
    end
end


-- command table
local cmds = {
    ["help"] = function()
        print("\nWelcome to Inio!\n\nCurrent commands: help, specs, config (non-functional currently), dir, clear, newfile (filename), editfile (filename), readfile (filename), loadfile (filename), rmfile (filename), cd (drivernumber), ")
    end,
    ["specs"] = function()
        print("\nInio Home Edition v1\n" .. amountOfDrivesWhichTheUserHasStoredInTheConfigFile .. " connected drive(s).")
    end,
    ["config"] = function()
        config()
    end,
    ["dir"] = function()
        print("")
        for i in pairs(fileMemory) do
            print(fileMemory[i])
        end
    end,
    ["clear"] = function()
        clear()
    end,
    ["newfile"] = function(filename)
        drive.writeFile(filename)
        for i in pairs(fileMemory) do
            memory[memoryStep] = i + 1
        end
        fileMemory[memory[memoryStep]] = filename
        memory[memoryStep] = nil
        memoryStep = 1
        drive.writeFile("filememory",table.concat(fileMemory, " "))
    end,
    ["readfile"] = function(filename)
        print("")
        print(drive.readFile(filename))
        print(" \n" .. currentDirectory)
    end,
    ["editfile"] = function(filename)
        if filename == "filememory" then
            print("Cannot edit a system file.")
            return
        end
        texteditor(filename)
    end,
    ["loadfile"] = function(filename)
        loadstring(drive.readFile(filename))()
    end,
    ["rmfile"] = function(filename)
        if filename == "filememory" then
            print("Cannot remove a system file.")
            return
        end
        drive.deleteFile(filename)
        local filememory = drive.readFile("filememory"):split(" ")
        local result = table.find(filememory, filename)
        table.remove(filememory, result)
        drive.writeFile("filememory", table.concat(filememory, " "))
        fileTemp = drive.readFile("filememory")
        fileMemory = fileTemp:split(" ")
    end,
    ["cd"] = function(drivernumber)
        currentDriver = tonumber(drivernumber)
        drive = disk.init(currentDriver)
        currentDirectory = drivers[currentDriver]
        fileMemory = mount()
    end
}

-- little startup briefing
clear()
print("Input 1 is automatically assigned to drive A. Please insert a disk drive and connect it to input 1 if you've haven't already.")
wait(6)
clear()
wait(1)
print("Inio Home Operating System\n v1 full release\n")

-- main
local function cli()
    print(currentDirectory)
    while wait(0.1) do
        userInput = input():split(" ")
        print(currentDirectory .. table.concat(userInput, " "))
	    local success = pcall(cmds[userInput[1]], userInput[2] or nil) -- sudo rm -rf /
        if success then
            -- apparently i cant just do if error then so this is my solution
            -- this is very impractical and i would love to not use an if statement but it works so im not changing it
            -- update i removed error and this code does not infact work
            -- update i think it works even though its highly impractical and makes me cringe when i look at it
        else
            print("Command not found.")
        end
    end
end



cli()
